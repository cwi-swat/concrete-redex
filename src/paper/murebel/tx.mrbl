entity Account {
  amount: int

  init 
    on open(initial: int): opened {
      this.amount = initial;
    } 

  final closed;
  
  state opened {
    on deposit(n: int) this.amount = this.amount + n;

    on withdraw(n: int) require this.amount > n 
      this.amount = this.amount - n;
    
    on close(): closed;
  }
}

entity Trans {
  amount: int
  from: Account
  to: Account
   
  init 
    on create(amount: int, from: Account, to: Account): ready {
      this.amount = amount;
      this.from = from;
      this.to = to;
    }
    
  state ready {
    on doIt(): booked {
      sync {
        this.from.withdraw(this.amount);
        this.to.deposit(this.amount);
      } 
    }
  }
    
  final booked;
  final canceled;
}

let from = new Account in
let to = new Account in {
  from.open(100);
  to.open(50);
  let tx1 = new Trans in {
     tx1.create(10, from, to);
     let to2 = new Account in {
       to2.open(0); // change the example so that tx1 creates the success conditions of tx2
       let tx2 = new Trans in {
         tx2.create(100, from, to2);
         par {
           tx1.doIt();
           tx2.doIt();
         }
       }
    }
  }
}

// Current results:
// 2422 edges in trace graph
// 1 end result: 
//#0: Account [opened] {amount: 90} 
//#1: Account [opened] {amount: 60}
//#2: Trans [booked] {amount: 10, from: #0, to: #1}
//#3: Account [opened] {amount: 0}
//#4: Trans [ready] {amount: 100, from: #0, to: #3}, ‚ä¢ fail;
// so tx1 is successful with the correct amounts (e.g. not -10)
// and tx2 fails in all situations
// 

 



